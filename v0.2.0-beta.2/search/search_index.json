{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"obstore","text":"<p>A Python interface and pyo3 integration to the Rust <code>object_store</code> crate, providing a uniform API for interacting with object storage services and local files.</p> <p>Run the same code in multiple clouds via a simple runtime configuration change.</p> <ul> <li>Easy to install with no Python dependencies.</li> <li>Sync and async API.</li> <li>Streaming downloads with configurable chunking.</li> <li>Automatically supports multipart uploads under the hood for large file objects.</li> <li>The underlying Rust library is production quality and used in large scale production systems, such as the Rust package registry crates.io.</li> <li>Simple API with static type checking.</li> <li>Helpers for constructing from environment variables and <code>boto3.Session</code> objects</li> </ul> <p>Supported object storage providers include:</p> <ul> <li>Amazon S3 and S3-compliant APIs like Cloudflare R2</li> <li>Google Cloud Storage</li> <li>Azure Blob Gen1 and Gen2 accounts (including ADLS Gen2)</li> <li>Local filesystem</li> <li>In-memory storage</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install obstore\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available on the website.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#constructing-a-store","title":"Constructing a store","text":"<p>Classes to construct a store are exported from the <code>obstore.store</code> submodule:</p> <ul> <li><code>S3Store</code>: Configure a connection to Amazon S3.</li> <li><code>GCSStore</code>: Configure a connection to Google Cloud Storage.</li> <li><code>AzureStore</code>: Configure a connection to Microsoft Azure Blob Storage.</li> <li><code>HTTPStore</code>: Configure a connection to a generic HTTP server</li> <li><code>LocalStore</code>: Local filesystem storage providing the same object store interface.</li> <li><code>MemoryStore</code>: A fully in-memory implementation of ObjectStore.</li> </ul>"},{"location":"#example","title":"Example","text":"<pre><code>import boto3\nfrom obstore.store import S3Store\n\nsession = boto3.Session()\nstore = S3Store.from_session(session, \"bucket-name\", config={\"AWS_REGION\": \"us-east-1\"})\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Each store class above has its own configuration, accessible through the <code>config</code> named parameter. This is covered in the docs, and string literals are in the type hints.</p> <p>Additional HTTP client configuration is available via the <code>client_options</code> named parameter.</p>"},{"location":"#interacting-with-a-store","title":"Interacting with a store","text":"<p>All methods for interacting with a store are exported as top-level functions (not methods on the <code>store</code> object):</p> <ul> <li><code>copy</code>: Copy an object from one path to another in the same object store.</li> <li><code>delete</code>: Delete the object at the specified location.</li> <li><code>get</code>: Return the bytes that are stored at the specified location.</li> <li><code>head</code>: Return the metadata for the specified location</li> <li><code>list</code>: List all the objects with the given prefix.</li> <li><code>put</code>: Save the provided bytes to the specified location</li> <li><code>rename</code>: Move an object from one path to another in the same object store.</li> </ul> <p>There are a few additional APIs useful for specific use cases:</p> <ul> <li><code>get_range</code>: Get a specific byte range from a file.</li> <li><code>get_ranges</code>: Get multiple byte ranges from a single file.</li> <li><code>list_with_delimiter</code>: List objects within a specific directory.</li> <li><code>sign</code>: Create a signed URL.</li> </ul> <p>All methods have a comparable async method with the same name plus an <code>_async</code> suffix.</p>"},{"location":"#example_1","title":"Example","text":"<pre><code>import obstore as obs\n\nstore = obs.store.MemoryStore()\n\nobs.put(store, \"file.txt\", b\"hello world!\")\nresponse = obs.get(store, \"file.txt\")\nresponse.meta\n# {'path': 'file.txt',\n#  'last_modified': datetime.datetime(2024, 10, 21, 16, 19, 45, 102620, tzinfo=datetime.timezone.utc),\n#  'size': 12,\n#  'e_tag': '0',\n#  'version': None}\nassert response.bytes() == b\"hello world!\"\n\nbyte_range = obs.get_range(store, \"file.txt\", offset=0, length=5)\nassert byte_range == b\"hello\"\n\nobs.copy(store, \"file.txt\", \"other.txt\")\nassert obs.get(store, \"other.txt\").bytes() == b\"hello world!\"\n</code></pre> <p>All of these methods also have <code>async</code> counterparts, suffixed with <code>_async</code>.</p> <pre><code>import obstore as obs\n\nstore = obs.store.MemoryStore()\n\nawait obs.put_async(store, \"file.txt\", b\"hello world!\")\nresponse = await obs.get_async(store, \"file.txt\")\nresponse.meta\n# {'path': 'file.txt',\n#  'last_modified': datetime.datetime(2024, 10, 21, 16, 20, 36, 477418, tzinfo=datetime.timezone.utc),\n#  'size': 12,\n#  'e_tag': '0',\n#  'version': None}\nassert await response.bytes_async() == b\"hello world!\"\n\nbyte_range = await obs.get_range_async(store, \"file.txt\", offset=0, length=5)\nassert byte_range == b\"hello\"\n\nawait obs.copy_async(store, \"file.txt\", \"other.txt\")\nresp = await obs.get_async(store, \"other.txt\")\nassert await resp.bytes_async() == b\"hello world!\"\n</code></pre>"},{"location":"#comparison-to-object-store-python","title":"Comparison to object-store-python","text":"<p>Read a detailed comparison to <code>object-store-python</code>, a previous Python library that also wraps the same Rust <code>object_store</code> crate.</p>"},{"location":"api/attributes/","title":"Attributes","text":""},{"location":"api/attributes/#obstore.Attribute","title":"obstore.Attribute  <code>module-attribute</code>","text":"<pre><code>Attribute = (\n    Literal[\n        \"Content-Disposition\",\n        \"Content-Encoding\",\n        \"Content-Language\",\n        \"Content-Type\",\n        \"Cache-Control\",\n    ]\n    | str\n)\n</code></pre> <p>Additional object attribute types.</p> <ul> <li> <p><code>\"Content-Disposition\"</code>: Specifies how the object should be handled by a browser.</p> <p>See Content-Disposition.</p> </li> <li> <p><code>\"Content-Encoding\"</code>: Specifies the encodings applied to the object.</p> <p>See Content-Encoding.</p> </li> <li> <p><code>\"Content-Language\"</code>: Specifies the language of the object.</p> <p>See Content-Language.</p> </li> <li> <p><code>\"Content-Type\"</code>: Specifies the MIME type of the object.</p> <p>This takes precedence over any client configuration.</p> <p>See Content-Type.</p> </li> <li> <p><code>\"Cache-Control\"</code>: Overrides cache control policy of the object.</p> <p>See Cache-Control.</p> </li> </ul> <p>Any other string key specifies a user-defined metadata field for the object.</p>"},{"location":"api/attributes/#obstore.Attributes","title":"obstore.Attributes  <code>module-attribute</code>","text":"<pre><code>Attributes = Dict[Attribute, str]\n</code></pre> <p>Additional attributes of an object</p> <p>Attributes can be specified in <code>put</code>/<code>put_async</code> and retrieved from <code>get</code>/<code>get_async</code>.</p> <p>Unlike ObjectMeta, Attributes are not returned by listing APIs</p>"},{"location":"api/copy/","title":"Copy","text":""},{"location":"api/copy/#obstore.copy","title":"obstore.copy","text":"<pre><code>copy(\n    store: ObjectStore, from_: str, to: str, *, overwrite: bool = True\n) -&gt; None\n</code></pre> <p>Copy an object from one path to another in the same object store.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>overwrite</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, if there exists an object at the destination, it will be overwritten. Performs an atomic operation if the underlying object storage supports it. If atomic operations are not supported by the underlying object storage (like S3) it will return an error.</p> <p>If <code>False</code>, will return an error if the destination already has an object.</p> </li> </ul>"},{"location":"api/copy/#obstore.copy_async","title":"obstore.copy_async  <code>async</code>","text":"<pre><code>copy_async(\n    store: ObjectStore, from_: str, to: str, *, overwrite: bool = True\n) -&gt; None\n</code></pre> <p>Call <code>copy</code> asynchronously.</p> <p>Refer to the documentation for copy.</p>"},{"location":"api/delete/","title":"Delete","text":""},{"location":"api/delete/#obstore.delete","title":"obstore.delete","text":"<pre><code>delete(store: ObjectStore, paths: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete the object at the specified location(s).</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>paths</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>The path or paths within the store to delete.</p> <p>When supported by the underlying store, this method will use bulk operations that delete more than one object per a request.</p> <p>If the object did not exist, the result may be an error or a success, depending on the behavior of the underlying store. For example, local filesystems, GCP, and Azure return an error, while S3 and in-memory will return Ok.</p> </li> </ul>"},{"location":"api/delete/#obstore.delete_async","title":"obstore.delete_async  <code>async</code>","text":"<pre><code>delete_async(store: ObjectStore, paths: str | Sequence[str]) -&gt; None\n</code></pre> <p>Call <code>delete</code> asynchronously.</p> <p>Refer to the documentation for delete.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#obstore.exceptions","title":"obstore.exceptions","text":""},{"location":"api/exceptions/#obstore.exceptions.AlreadyExistsError","title":"AlreadyExistsError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the object already exists.</p>"},{"location":"api/exceptions/#obstore.exceptions.GenericError","title":"GenericError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>A fallback error type when no variant matches.</p>"},{"location":"api/exceptions/#obstore.exceptions.InvalidPathError","title":"InvalidPathError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error for invalid path.</p>"},{"location":"api/exceptions/#obstore.exceptions.JoinError","title":"JoinError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when <code>tokio::spawn</code> failed.</p>"},{"location":"api/exceptions/#obstore.exceptions.NotFoundError","title":"NotFoundError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the object is not found at given location.</p>"},{"location":"api/exceptions/#obstore.exceptions.NotModifiedError","title":"NotModifiedError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the object at the location isn't modified.</p>"},{"location":"api/exceptions/#obstore.exceptions.NotSupportedError","title":"NotSupportedError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the attempted operation is not supported.</p>"},{"location":"api/exceptions/#obstore.exceptions.ObstoreError","title":"ObstoreError","text":"<p>               Bases: <code>Exception</code></p> <p>The base exception class</p>"},{"location":"api/exceptions/#obstore.exceptions.PermissionDeniedError","title":"PermissionDeniedError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the used credentials don't have enough permission to perform the requested operation</p>"},{"location":"api/exceptions/#obstore.exceptions.PreconditionError","title":"PreconditionError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the required conditions failed for the operation.</p>"},{"location":"api/exceptions/#obstore.exceptions.UnauthenticatedError","title":"UnauthenticatedError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when the used credentials lack valid authentication.</p>"},{"location":"api/exceptions/#obstore.exceptions.UnknownConfigurationKeyError","title":"UnknownConfigurationKeyError","text":"<p>               Bases: <code>ObstoreError</code></p> <p>Error when a configuration key is invalid for the store used.</p>"},{"location":"api/get/","title":"Get","text":""},{"location":"api/get/#obstore.get","title":"obstore.get","text":"<pre><code>get(\n    store: ObjectStore, path: str, *, options: GetOptions | None = None\n) -&gt; GetResult\n</code></pre> <p>Return the bytes that are stored at the specified location.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>options</code>               (<code>GetOptions | None</code>, default:                   <code>None</code> )           \u2013            <p>options for accessing the file. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GetResult</code>           \u2013            <p>GetResult</p> </li> </ul>"},{"location":"api/get/#obstore.get_async","title":"obstore.get_async  <code>async</code>","text":"<pre><code>get_async(\n    store: ObjectStore, path: str, *, options: GetOptions | None = None\n) -&gt; GetResult\n</code></pre> <p>Call <code>get</code> asynchronously.</p> <p>Refer to the documentation for get.</p>"},{"location":"api/get/#obstore.get_range","title":"obstore.get_range","text":"<pre><code>get_range(store: ObjectStore, path: str, offset: int, length: int) -&gt; Buffer\n</code></pre> <p>Return the bytes that are stored at the specified location in the given byte range.</p> <p>If the given range is zero-length or starts after the end of the object, an error will be returned. Additionally, if the range ends after the end of the object, the entire remainder of the object will be returned. Otherwise, the exact requested range will be returned.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>offset</code>               (<code>int</code>)           \u2013            <p>The start of the byte range.</p> </li> <li> <code>length</code>               (<code>int</code>)           \u2013            <p>The number of bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Buffer</code>           \u2013            <p>A <code>Buffer</code> object implementing the Python buffer protocol, allowing zero-copy access to the underlying memory provided by Rust.</p> </li> </ul>"},{"location":"api/get/#obstore.get_range_async","title":"obstore.get_range_async  <code>async</code>","text":"<pre><code>get_range_async(\n    store: ObjectStore, path: str, offset: int, length: int\n) -&gt; Buffer\n</code></pre> <p>Call <code>get_range</code> asynchronously.</p> <p>Refer to the documentation for get_range.</p>"},{"location":"api/get/#obstore.get_ranges","title":"obstore.get_ranges","text":"<pre><code>get_ranges(\n    store: ObjectStore,\n    path: str,\n    offsets: Sequence[int],\n    lengths: Sequence[int],\n) -&gt; List[Buffer]\n</code></pre> <p>Return the bytes that are stored at the specified location in the given byte ranges</p> <p>To improve performance this will:</p> <ul> <li>Combine ranges less than 10MB apart into a single call to <code>fetch</code></li> <li>Make multiple <code>fetch</code> requests in parallel (up to maximum of 10)</li> </ul> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>offsets</code>               (<code>Sequence[int]</code>)           \u2013            <p>A sequence of <code>int</code> where each offset starts.</p> </li> <li> <code>lengths</code>               (<code>Sequence[int]</code>)           \u2013            <p>A sequence of <code>int</code> representing the number of bytes within each range.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Buffer]</code>           \u2013            <p>A sequence of <code>Buffer</code>, one for each range. This <code>Buffer</code> object implements the Python buffer protocol, allowing zero-copy access to the underlying memory provided by Rust.</p> </li> </ul>"},{"location":"api/get/#obstore.get_ranges_async","title":"obstore.get_ranges_async  <code>async</code>","text":"<pre><code>get_ranges_async(\n    store: ObjectStore,\n    path: str,\n    offsets: Sequence[int],\n    lengths: Sequence[int],\n) -&gt; List[Buffer]\n</code></pre> <p>Call <code>get_ranges</code> asynchronously.</p> <p>Refer to the documentation for get_ranges.</p>"},{"location":"api/get/#obstore.GetOptions","title":"obstore.GetOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options for a get request.</p> <p>All options are optional.</p>"},{"location":"api/get/#obstore.GetOptions.head","title":"head  <code>instance-attribute</code>","text":"<pre><code>head: bool\n</code></pre> <p>Request transfer of no content</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-head</p>"},{"location":"api/get/#obstore.GetOptions.if_match","title":"if_match  <code>instance-attribute</code>","text":"<pre><code>if_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> matches otherwise returning [<code>Error::Precondition</code>]</p> <p>See datatracker.ietf.org/doc/html/rfc9110#name-if-match</p> <p>Examples:</p> <pre><code>If-Match: \"xyzzy\"\nIf-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-Match: *\n</code></pre>"},{"location":"api/get/#obstore.GetOptions.if_modified_since","title":"if_modified_since  <code>instance-attribute</code>","text":"<pre><code>if_modified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has not been modified since otherwise returning [<code>Error::Precondition</code>]</p> <p>Some stores, such as S3, will only return <code>NotModified</code> for exact timestamp matches, instead of for any timestamp greater than or equal.</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.4</p>"},{"location":"api/get/#obstore.GetOptions.if_none_match","title":"if_none_match  <code>instance-attribute</code>","text":"<pre><code>if_none_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> does not match otherwise returning [<code>Error::NotModified</code>]</p> <p>See datatracker.ietf.org/doc/html/rfc9110#section-13.1.2</p> <p>Examples:</p> <pre><code>If-None-Match: \"xyzzy\"\nIf-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-None-Match: *\n</code></pre>"},{"location":"api/get/#obstore.GetOptions.if_unmodified_since","title":"if_unmodified_since  <code>instance-attribute</code>","text":"<pre><code>if_unmodified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has been modified since</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.3</p>"},{"location":"api/get/#obstore.GetOptions.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>Request a particular object version</p>"},{"location":"api/get/#obstore.GetResult","title":"obstore.GetResult","text":"<p>Result for a get request.</p> <p>You can materialize the entire buffer by using either <code>bytes</code> or <code>bytes_async</code>, or you can stream the result using <code>stream</code>. <code>__iter__</code> and <code>__aiter__</code> are implemented as aliases to <code>stream</code>, so you can alternatively call <code>iter()</code> or <code>aiter()</code> on <code>GetResult</code> to start an iterator.</p> <p>Using as an async iterator: <pre><code>resp = await obs.get_async(store, path)\n# 5MB chunk size in stream\nstream = resp.stream(min_chunk_size=5 * 1024 * 1024)\nasync for buf in stream:\n    print(len(buf))\n</code></pre></p> <p>Using as a sync iterator: <pre><code>resp = obs.get(store, path)\n# 20MB chunk size in stream\nstream = resp.stream(min_chunk_size=20 * 1024 * 1024)\nfor buf in stream:\n    print(len(buf))\n</code></pre></p> <p>Note that after calling <code>bytes</code>, <code>bytes_async</code>, or <code>stream</code>, you will no longer be able to call other methods on this object, such as the <code>meta</code> attribute.</p>"},{"location":"api/get/#obstore.GetResult.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>Additional object attributes.</p> <p>This must be accessed before calling <code>stream</code>, <code>bytes</code>, or <code>bytes_async</code>.</p>"},{"location":"api/get/#obstore.GetResult.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: ObjectMeta\n</code></pre> <p>The ObjectMeta for this object.</p> <p>This must be accessed before calling <code>stream</code>, <code>bytes</code>, or <code>bytes_async</code>.</p>"},{"location":"api/get/#obstore.GetResult.range","title":"range  <code>property</code>","text":"<pre><code>range: Tuple[int, int]\n</code></pre> <p>The range of bytes returned by this request.</p> <p>This must be accessed before calling <code>stream</code>, <code>bytes</code>, or <code>bytes_async</code>.</p>"},{"location":"api/get/#obstore.GetResult.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; BytesStream\n</code></pre> <p>Return a chunked stream over the result's bytes with the default (10MB) chunk size.</p>"},{"location":"api/get/#obstore.GetResult.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; BytesStream\n</code></pre> <p>Return a chunked stream over the result's bytes with the default (10MB) chunk size.</p>"},{"location":"api/get/#obstore.GetResult.bytes","title":"bytes","text":"<pre><code>bytes() -&gt; bytes\n</code></pre> <p>Collects the data into bytes</p>"},{"location":"api/get/#obstore.GetResult.bytes_async","title":"bytes_async  <code>async</code>","text":"<pre><code>bytes_async() -&gt; bytes\n</code></pre> <p>Collects the data into bytes</p>"},{"location":"api/get/#obstore.GetResult.stream","title":"stream","text":"<pre><code>stream(min_chunk_size: int = 10 * 1024 * 1024) -&gt; BytesStream\n</code></pre> <p>Return a chunked stream over the result's bytes.</p> <p>Parameters:</p> <ul> <li> <code>min_chunk_size</code>               (<code>int</code>, default:                   <code>10 * 1024 * 1024</code> )           \u2013            <p>The minimum size in bytes for each chunk in the returned <code>BytesStream</code>. All chunks except for the last chunk will be at least this size. Defaults to 1010241024 (10MB).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BytesStream</code>           \u2013            <p>A chunked stream</p> </li> </ul>"},{"location":"api/get/#obstore.Buffer","title":"obstore.Buffer","text":"<p>               Bases: <code>Buffer</code></p> <p>A buffer implementing the Python buffer protocol, allowing zero-copy access to the underlying memory provided by Rust.</p> <p>You can pass this to <code>memoryview</code> for a zero-copy view into the underlying data.</p>"},{"location":"api/get/#obstore.Buffer.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Copy this buffer into a Python <code>bytes</code> object.</p>"},{"location":"api/head/","title":"Head","text":""},{"location":"api/head/#obstore.head","title":"obstore.head","text":"<pre><code>head(store: ObjectStore, path: str) -&gt; ObjectMeta\n</code></pre> <p>Return the metadata for the specified location</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ObjectMeta</code>           \u2013            <p>ObjectMeta</p> </li> </ul>"},{"location":"api/head/#obstore.head_async","title":"obstore.head_async  <code>async</code>","text":"<pre><code>head_async(store: ObjectStore, path: str) -&gt; ObjectMeta\n</code></pre> <p>Call <code>head</code> asynchronously.</p> <p>Refer to the documentation for head.</p>"},{"location":"api/list/","title":"List","text":""},{"location":"api/list/#obstore.list","title":"obstore.list","text":"<pre><code>list(\n    store: ObjectStore,\n    prefix: str | None = None,\n    *,\n    offset: str | None = None,\n    chunk_size: int = 50,\n    return_arrow: Literal[True]\n) -&gt; ListStream[RecordBatch]\n</code></pre><pre><code>list(\n    store: ObjectStore,\n    prefix: str | None = None,\n    *,\n    offset: str | None = None,\n    chunk_size: int = 50,\n    return_arrow: Literal[False] = False\n) -&gt; ListStream[List[ObjectMeta]]\n</code></pre> <pre><code>list(\n    store: ObjectStore,\n    prefix: str | None = None,\n    *,\n    offset: str | None = None,\n    chunk_size: int = 50,\n    return_arrow: bool = False\n) -&gt; ListStream[RecordBatch] | ListStream[List[ObjectMeta]]\n</code></pre> <p>List all the objects with the given prefix.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. List is recursive, i.e. <code>foo/bar/more/x</code> will be included.</p> <p>Examples:</p> <p>Synchronously iterate through list results:</p> <pre><code>import obstore as obs\nfrom obstore.store import MemoryStore\n\nstore = MemoryStore()\nfor i in range(100):\n    obs.put(store, f\"file{i}.txt\", b\"foo\")\n\nstream = obs.list(store, chunk_size=10)\nfor list_result in stream:\n    print(list_result[0])\n    # {'path': 'file0.txt', 'last_modified': datetime.datetime(2024, 10, 23, 19, 19, 28, 781723, tzinfo=datetime.timezone.utc), 'size': 3, 'e_tag': '0', 'version': None}\n    break\n</code></pre> <p>Asynchronously iterate through list results. Just change <code>for</code> to <code>async for</code>:</p> <pre><code>stream = obs.list(store, chunk_size=10)\nasync for list_result in stream:\n    print(list_result[2])\n    # {'path': 'file10.txt', 'last_modified': datetime.datetime(2024, 10, 23, 19, 21, 46, 224725, tzinfo=datetime.timezone.utc), 'size': 3, 'e_tag': '10', 'version': None}\n    break\n</code></pre> <p>Return large list results as Arrow. This is most useful with large list operations. In this case you may want to increase the <code>chunk_size</code> parameter.</p> <pre><code>stream = obs.list(store, chunk_size=1000, return_arrow=True)\n# Stream is now an iterable/async iterable of `RecordBatch`es\nfor batch in stream:\n    print(batch.num_rows) # 100\n\n    # If desired, convert to a pyarrow RecordBatch (zero-copy) with\n    # `pyarrow.record_batch(batch)`\n    break\n</code></pre> <p>Collect all list results into a single Arrow <code>RecordBatch</code>.</p> <pre><code>stream = obs.list(store, return_arrow=True)\nbatch = stream.collect()\n</code></pre> <p>Note</p> <p>The order of returned <code>ObjectMeta</code> is not guaranteed</p> <p>Note</p> <p>There is no async version of this method, because <code>list</code> is not async under the hood, rather it only instantiates a stream, which can be polled in synchronous or asynchronous fashion. See <code>ListStream</code>.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within ObjectStore to use for listing. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>offset</code>               (<code>str | None</code>)           \u2013            <p>If provided, list all the objects with the given prefix and a location greater than <code>offset</code>. Defaults to <code>None</code>.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>)           \u2013            <p>The number of items to collect per chunk in the returned (async) iterator. All chunks except for the last one will have this many items. This is ignored in the <code>collect</code> and <code>collect_async</code> methods of <code>ListStream</code>.</p> </li> <li> <code>return_arrow</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, return each batch of list items as an Arrow <code>RecordBatch</code>, not as a list of Python <code>dict</code>s. Arrow removes serialization overhead between Rust and Python and so this can be significantly faster for large list operations. Defaults to <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ListStream[RecordBatch] | ListStream[List[ObjectMeta]]</code>           \u2013            <p>A ListStream, which you can iterate through to access list results.</p> </li> </ul>"},{"location":"api/list/#obstore.list_with_delimiter","title":"obstore.list_with_delimiter","text":"<pre><code>list_with_delimiter(\n    store: ObjectStore, prefix: str | None = None\n) -&gt; ListResult\n</code></pre> <p>List objects with the given prefix and an implementation specific delimiter. Returns common prefixes (directories) in addition to object metadata.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. List is not recursive, i.e. <code>foo/bar/more/x</code> will not be included.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within ObjectStore to use for listing. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ListResult</code>           \u2013            <p>ListResult</p> </li> </ul>"},{"location":"api/list/#obstore.list_with_delimiter_async","title":"obstore.list_with_delimiter_async  <code>async</code>","text":"<pre><code>list_with_delimiter_async(\n    store: ObjectStore, prefix: str | None = None\n) -&gt; ListResult\n</code></pre> <p>Call <code>list_with_delimiter</code> asynchronously.</p> <p>Refer to the documentation for list_with_delimiter.</p>"},{"location":"api/list/#obstore.ObjectMeta","title":"obstore.ObjectMeta","text":"<p>               Bases: <code>TypedDict</code></p> <p>The metadata that describes an object.</p>"},{"location":"api/list/#obstore.ObjectMeta.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/list/#obstore.ObjectMeta.last_modified","title":"last_modified  <code>instance-attribute</code>","text":"<pre><code>last_modified: datetime\n</code></pre> <p>The last modified time</p>"},{"location":"api/list/#obstore.ObjectMeta.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>The full path to the object</p>"},{"location":"api/list/#obstore.ObjectMeta.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The size in bytes of the object</p>"},{"location":"api/list/#obstore.ObjectMeta.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for this object</p>"},{"location":"api/list/#obstore.ListResult","title":"obstore.ListResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result of a list call that includes objects, prefixes (directories) and a token for the next set of results. Individual result sets may be limited to 1,000 objects based on the underlying object storage's limitations.</p>"},{"location":"api/list/#obstore.ListResult.common_prefixes","title":"common_prefixes  <code>instance-attribute</code>","text":"<pre><code>common_prefixes: List[str]\n</code></pre> <p>Prefixes that are common (like directories)</p>"},{"location":"api/list/#obstore.ListResult.objects","title":"objects  <code>instance-attribute</code>","text":"<pre><code>objects: List[ObjectMeta]\n</code></pre> <p>Object metadata for the listing</p>"},{"location":"api/list/#obstore.ListStream","title":"obstore.ListStream","text":"<p>               Bases: <code>Generic[ChunkType]</code></p> <p>A stream of ObjectMeta that can be polled in a sync or async fashion.</p>"},{"location":"api/list/#obstore.ListStream.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; Self\n</code></pre> <p>Return <code>Self</code> as an async iterator.</p>"},{"location":"api/list/#obstore.ListStream.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; ChunkType\n</code></pre> <p>Return the next chunk of ObjectMeta in the stream.</p>"},{"location":"api/list/#obstore.ListStream.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Self\n</code></pre> <p>Return <code>Self</code> as an async iterator.</p>"},{"location":"api/list/#obstore.ListStream.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; ChunkType\n</code></pre> <p>Return the next chunk of ObjectMeta in the stream.</p>"},{"location":"api/list/#obstore.ListStream.collect","title":"collect","text":"<pre><code>collect() -&gt; ChunkType\n</code></pre> <p>Collect all remaining ObjectMeta objects in the stream.</p> <p>This ignores the <code>chunk_size</code> parameter from the <code>list</code> call and collects all remaining data into a single chunk.</p>"},{"location":"api/list/#obstore.ListStream.collect_async","title":"collect_async  <code>async</code>","text":"<pre><code>collect_async() -&gt; ChunkType\n</code></pre> <p>Collect all remaining ObjectMeta objects in the stream.</p> <p>This ignores the <code>chunk_size</code> parameter from the <code>list</code> call and collects all remaining data into a single chunk.</p>"},{"location":"api/put/","title":"Put","text":""},{"location":"api/put/#obstore.put","title":"obstore.put","text":"<pre><code>put(\n    store: ObjectStore,\n    path: str,\n    file: IO[bytes] | Path | bytes,\n    *,\n    attributes: Attributes | None = None,\n    tags: Dict[str, str] | None = None,\n    mode: PutMode | None = None,\n    use_multipart: bool | None = None,\n    chunk_size: int = 5 * 1024 * 1024,\n    max_concurrency: int = 12\n) -&gt; PutResult\n</code></pre> <p>Save the provided bytes to the specified location</p> <p>The operation is guaranteed to be atomic, it will either successfully write the entirety of <code>file</code> to <code>location</code>, or fail. No clients should be able to observe a partially written object.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore for where to save the file.</p> </li> <li> <code>file</code>               (<code>IO[bytes] | Path | bytes</code>)           \u2013            <p>The object to upload. Can either be file-like, a <code>Path</code> to a local file, or a <code>bytes</code> object.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>mode</code>               (<code>PutMode | None</code>)           \u2013            <p>Configure the <code>PutMode</code> for this operation. If this provided and is not <code>\"overwrite\"</code>, a non-multipart upload will be performed. Defaults to <code>\"overwrite\"</code>.</p> </li> <li> <code>attributes</code>               (<code>Attributes | None</code>)           \u2013            <p>Provide a set of <code>Attributes</code>. Defaults to <code>None</code>.</p> </li> <li> <code>tags</code>               (<code>Dict[str, str] | None</code>)           \u2013            <p>Provide tags for this object. Defaults to <code>None</code>.</p> </li> <li> <code>use_multipart</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use a multipart upload under the hood. Defaults using a multipart upload if the length of the file is greater than <code>chunk_size</code>.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>)           \u2013            <p>The size of chunks to use within each part of the multipart upload. Defaults to 5 MB.</p> </li> <li> <code>max_concurrency</code>               (<code>int</code>)           \u2013            <p>The maximum number of chunks to upload concurrently. Defaults to 12.</p> </li> </ul>"},{"location":"api/put/#obstore.put_async","title":"obstore.put_async  <code>async</code>","text":"<pre><code>put_async(\n    store: ObjectStore,\n    path: str,\n    file: IO[bytes] | Path | bytes,\n    *,\n    attributes: Attributes | None = None,\n    tags: Dict[str, str] | None = None,\n    mode: PutMode | None = None,\n    use_multipart: bool | None = None,\n    chunk_size: int = 5 * 1024 * 1024,\n    max_concurrency: int = 12\n) -&gt; PutResult\n</code></pre> <p>Call <code>put</code> asynchronously.</p> <p>Refer to the documentation for put.</p>"},{"location":"api/put/#obstore.PutResult","title":"obstore.PutResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result for a put request.</p>"},{"location":"api/put/#obstore.PutResult.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the newly created object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/put/#obstore.PutResult.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for the newly created object.</p>"},{"location":"api/put/#obstore.UpdateVersion","title":"obstore.UpdateVersion","text":"<p>               Bases: <code>TypedDict</code></p> <p>Uniquely identifies a version of an object to update</p> <p>Stores will use differing combinations of <code>e_tag</code> and <code>version</code> to provide conditional updates, and it is therefore recommended applications preserve both</p>"},{"location":"api/put/#obstore.UpdateVersion.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the newly created object.</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/put/#obstore.UpdateVersion.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for the newly created object.</p>"},{"location":"api/put/#obstore.PutMode","title":"obstore.PutMode  <code>module-attribute</code>","text":"<pre><code>PutMode = Literal['create', 'overwrite'] | UpdateVersion\n</code></pre> <p>Configure preconditions for the put operation</p> <p>If a string is provided, it must be one of:</p> <ul> <li><code>\"overwrite\"</code>: Perform an atomic write operation, overwriting any object present at the provided path.</li> <li><code>\"create\"</code>: Perform an atomic write operation, returning <code>AlreadyExistsError</code> if an object already exists at the provided path</li> </ul> <p>If a <code>dict</code> is provided, it must meet the criteria of <code>UpdateVersion</code>. In this case, perform an atomic write operation if the current version of the object matches the provided <code>UpdateVersion</code>, returning <code>PreconditionError</code> otherwise.</p>"},{"location":"api/rename/","title":"Rename","text":""},{"location":"api/rename/#obstore.rename","title":"obstore.rename","text":"<pre><code>rename(\n    store: ObjectStore, from_: str, to: str, *, overwrite: bool = True\n) -&gt; None\n</code></pre> <p>Move an object from one path to another in the same object store.</p> <p>By default, this is implemented as a copy and then delete source. It may not check when deleting source that it was the same object that was originally copied.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>overwrite</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, if there exists an object at the destination, it will be overwritten. If <code>False</code>, will return an error if the destination already has an object.</p> </li> </ul>"},{"location":"api/rename/#obstore.rename_async","title":"obstore.rename_async  <code>async</code>","text":"<pre><code>rename_async(\n    store: ObjectStore, from_: str, to: str, *, overwrite: bool = True\n) -&gt; None\n</code></pre> <p>Call <code>rename</code> asynchronously.</p> <p>Refer to the documentation for rename.</p>"},{"location":"api/sign/","title":"Sign","text":""},{"location":"api/sign/#obstore.sign","title":"obstore.sign","text":"<pre><code>sign(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    paths: str,\n    expires_in: timedelta,\n) -&gt; str\n</code></pre><pre><code>sign(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    paths: Sequence[str],\n    expires_in: timedelta,\n) -&gt; List[str]\n</code></pre> <pre><code>sign(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    paths: str | Sequence[str],\n    expires_in: timedelta,\n) -&gt; str | List[str]\n</code></pre> <p>Create a signed URL.</p> <p>Given the intended <code>method</code> and <code>paths</code> to use and the desired length of time for which the URL should be valid, return a signed URL created with the object store implementation's credentials such that the URL can be handed to something that doesn't have access to the object store's credentials, to allow limited access to the object store.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>SignCapableStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>method</code>               (<code>HTTP_METHOD</code>)           \u2013            <p>The HTTP method to use.</p> </li> <li> <code>paths</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>The path(s) within ObjectStore to retrieve. If</p> </li> <li> <code>expires_in</code>               (<code>timedelta</code>)           \u2013            <p>How long the signed URL(s) should be valid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/sign/#obstore.sign_async","title":"obstore.sign_async  <code>async</code>","text":"<pre><code>sign_async(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    paths: str,\n    expires_in: timedelta,\n) -&gt; str\n</code></pre><pre><code>sign_async(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    paths: Sequence[str],\n    expires_in: timedelta,\n) -&gt; List[str]\n</code></pre> <pre><code>sign_async(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    paths: str | Sequence[str],\n    expires_in: timedelta,\n) -&gt; str | List[str]\n</code></pre> <p>Call <code>sign</code> asynchronously.</p> <p>Refer to the documentation for sign.</p>"},{"location":"api/sign/#obstore.SignCapableStore","title":"obstore.SignCapableStore  <code>module-attribute</code>","text":"<pre><code>SignCapableStore = AzureStore | GCSStore | S3Store\n</code></pre> <p>ObjectStore instances that are capable of signing.</p>"},{"location":"api/sign/#obstore.HTTP_METHOD","title":"obstore.HTTP_METHOD  <code>module-attribute</code>","text":"<pre><code>HTTP_METHOD = Literal[\n    \"GET\",\n    \"PUT\",\n    \"POST\",\n    \"HEAD\",\n    \"PATCH\",\n    \"TRACE\",\n    \"DELETE\",\n    \"OPTIONS\",\n    \"CONNECT\",\n]\n</code></pre> <p>Allowed HTTP Methods for signing.</p>"},{"location":"api/store/","title":"ObjectStore","text":""},{"location":"api/store/#obstore.store.ObjectStore","title":"obstore.store.ObjectStore  <code>module-attribute</code>","text":"<pre><code>ObjectStore = (\n    AzureStore | GCSStore | HTTPStore | S3Store | LocalStore | MemoryStore\n)\n</code></pre> <p>All supported ObjectStore implementations.</p>"},{"location":"api/store/aws/","title":"AWS S3","text":""},{"location":"api/store/aws/#obstore.store.S3Store","title":"obstore.store.S3Store","text":"<p>Configure a connection to Amazon S3 using the specified credentials in the specified Amazon region and bucket.</p>"},{"location":"api/store/aws/#obstore.store.S3Store.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(\n    bucket: str,\n    *,\n    config: Dict[S3ConfigKey | str, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; S3Store\n</code></pre> <p>Construct a new S3Store with regular AWS environment variables</p> <p>Variables extracted from environment:</p> <ul> <li><code>AWS_ACCESS_KEY_ID</code> -&gt; access_key_id</li> <li><code>AWS_SECRET_ACCESS_KEY</code> -&gt; secret_access_key</li> <li><code>AWS_DEFAULT_REGION</code> -&gt; region</li> <li><code>AWS_ENDPOINT</code> -&gt; endpoint</li> <li><code>AWS_SESSION_TOKEN</code> -&gt; token</li> <li><code>AWS_CONTAINER_CREDENTIALS_RELATIVE_URI</code> -&gt; docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html</li> <li><code>AWS_ALLOW_HTTP</code> -&gt; set to \"true\" to permit HTTP connections without TLS</li> </ul> <p>Parameters:</p> <ul> <li> <code>bucket</code>               (<code>str</code>)           \u2013            <p>The AWS bucket to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[S3ConfigKey | str, str] | None</code>)           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the environment. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>S3Store</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#obstore.store.S3Store.from_session","title":"from_session  <code>classmethod</code>","text":"<pre><code>from_session(\n    session: Session | Session,\n    bucket: str,\n    *,\n    config: Dict[S3ConfigKey | str, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; S3Store\n</code></pre> <p>Construct a new S3Store with credentials inferred from a boto3 Session</p> <p>Parameters:</p> <ul> <li> <code>session</code>               (<code>Session | Session</code>)           \u2013            <p>The boto3.Session or botocore.session.Session to infer credentials from.</p> </li> <li> <code>bucket</code>               (<code>str</code>)           \u2013            <p>The AWS bucket to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[S3ConfigKey | str, str] | None</code>)           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the session. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>S3Store</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#obstore.store.S3Store.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: Dict[S3ConfigKey | str, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; S3Store\n</code></pre> <p>Parse available connection info from a well-known storage URL.</p> <p>The supported url schemes are:</p> <ul> <li><code>s3://&lt;bucket&gt;/&lt;path&gt;</code></li> <li><code>s3a://&lt;bucket&gt;/&lt;path&gt;</code></li> <li><code>https://s3.&lt;region&gt;.amazonaws.com/&lt;bucket&gt;</code></li> <li><code>https://&lt;bucket&gt;.s3.&lt;region&gt;.amazonaws.com</code></li> <li><code>https://ACCOUNT_ID.r2.cloudflarestorage.com/bucket</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[S3ConfigKey | str, str] | None</code>)           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>S3Store</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#obstore.store.S3ConfigKey","title":"obstore.store.S3ConfigKey  <code>module-attribute</code>","text":"<pre><code>S3ConfigKey = Literal[\n    \"access_key_id\",\n    \"aws_access_key_id\",\n    \"aws_allow_http\",\n    \"aws_bucket_name\",\n    \"aws_bucket\",\n    \"aws_checksum_algorithm\",\n    \"aws_conditional_put\",\n    \"aws_container_credentials_relative_uri\",\n    \"aws_copy_if_not_exists\",\n    \"aws_default_region\",\n    \"aws_disable_tagging\",\n    \"aws_endpoint_url\",\n    \"aws_endpoint\",\n    \"aws_imdsv1_fallback\",\n    \"aws_metadata_endpoint\",\n    \"aws_region\",\n    \"aws_s3_express\",\n    \"aws_secret_access_key\",\n    \"aws_server_side_encryption\",\n    \"aws_session_token\",\n    \"aws_skip_signature\",\n    \"aws_sse_bucket_key_enabled\",\n    \"aws_sse_kms_key_id\",\n    \"aws_token\",\n    \"aws_unsigned_payload\",\n    \"aws_virtual_hosted_style_request\",\n    \"bucket_name\",\n    \"bucket\",\n    \"checksum_algorithm\",\n    \"conditional_put\",\n    \"copy_if_not_exists\",\n    \"default_region\",\n    \"disable_tagging\",\n    \"endpoint_url\",\n    \"endpoint\",\n    \"imdsv1_fallback\",\n    \"metadata_endpoint\",\n    \"region\",\n    \"s3_express\",\n    \"secret_access_key\",\n    \"session_token\",\n    \"skip_signature\",\n    \"token\",\n    \"unsigned_payload\",\n    \"virtual_hosted_style_request\",\n    \"ACCESS_KEY_ID\",\n    \"AWS_ACCESS_KEY_ID\",\n    \"AWS_ALLOW_HTTP\",\n    \"AWS_BUCKET_NAME\",\n    \"AWS_BUCKET\",\n    \"AWS_CHECKSUM_ALGORITHM\",\n    \"AWS_CONDITIONAL_PUT\",\n    \"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\",\n    \"AWS_COPY_IF_NOT_EXISTS\",\n    \"AWS_DEFAULT_REGION\",\n    \"AWS_DISABLE_TAGGING\",\n    \"AWS_ENDPOINT_URL\",\n    \"AWS_ENDPOINT\",\n    \"AWS_IMDSV1_FALLBACK\",\n    \"AWS_METADATA_ENDPOINT\",\n    \"AWS_REGION\",\n    \"AWS_S3_EXPRESS\",\n    \"AWS_SECRET_ACCESS_KEY\",\n    \"AWS_SERVER_SIDE_ENCRYPTION\",\n    \"AWS_SESSION_TOKEN\",\n    \"AWS_SKIP_SIGNATURE\",\n    \"AWS_SSE_BUCKET_KEY_ENABLED\",\n    \"AWS_SSE_KMS_KEY_ID\",\n    \"AWS_TOKEN\",\n    \"AWS_UNSIGNED_PAYLOAD\",\n    \"AWS_VIRTUAL_HOSTED_STYLE_REQUEST\",\n    \"BUCKET_NAME\",\n    \"BUCKET\",\n    \"CHECKSUM_ALGORITHM\",\n    \"CONDITIONAL_PUT\",\n    \"COPY_IF_NOT_EXISTS\",\n    \"DEFAULT_REGION\",\n    \"DISABLE_TAGGING\",\n    \"ENDPOINT_URL\",\n    \"ENDPOINT\",\n    \"IMDSV1_FALLBACK\",\n    \"METADATA_ENDPOINT\",\n    \"REGION\",\n    \"S3_EXPRESS\",\n    \"SECRET_ACCESS_KEY\",\n    \"SESSION_TOKEN\",\n    \"SKIP_SIGNATURE\",\n    \"TOKEN\",\n    \"UNSIGNED_PAYLOAD\",\n    \"VIRTUAL_HOSTED_STYLE_REQUEST\",\n]\n</code></pre> <p>Valid AWS S3 configuration keys.</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>aws_access_key_id</code>, <code>access_key_id</code>: AWS Access Key</li> <li><code>aws_secret_access_key</code>, <code>secret_access_key</code>: Secret Access Key</li> <li><code>aws_region</code>, <code>region</code>: Region</li> <li><code>aws_default_region</code>, <code>default_region</code>: Default region</li> <li><code>aws_bucket</code>, <code>aws_bucket_name</code>, <code>bucket</code>, <code>bucket_name</code>: Bucket name</li> <li><code>aws_endpoint</code>, <code>aws_endpoint_url</code>, <code>endpoint</code>, <code>endpoint_url</code>: Sets custom endpoint for communicating with AWS S3.</li> <li><code>aws_session_token</code>, <code>aws_token</code>, <code>session_token</code>, <code>token</code>: Token to use for requests (passed to underlying provider)</li> <li><code>aws_imdsv1_fallback</code>, <code>imdsv1_fallback</code>: Fall back to ImdsV1</li> <li><code>aws_virtual_hosted_style_request</code>, <code>virtual_hosted_style_request</code>: If virtual hosted style request has to be used</li> <li><code>aws_unsigned_payload</code>, <code>unsigned_payload</code>: Avoid computing payload checksum when calculating signature.</li> <li><code>aws_metadata_endpoint</code>, <code>metadata_endpoint</code>: Set the instance metadata endpoint</li> <li><code>aws_disable_tagging</code>, <code>disable_tagging</code>: Disable tagging objects. This can be desirable if not supported by the backing store.</li> <li><code>aws_s3_express</code>, <code>s3_express</code>: Enable Support for S3 Express One Zone</li> </ul>"},{"location":"api/store/azure/","title":"Microsoft Azure","text":""},{"location":"api/store/azure/#obstore.store.AzureStore","title":"obstore.store.AzureStore","text":"<p>Configure a connection to Microsoft Azure Blob Storage container using the specified credentials.</p>"},{"location":"api/store/azure/#obstore.store.AzureStore.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(\n    container: str,\n    *,\n    config: Dict[AzureConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; AzureStore\n</code></pre> <p>Construct a new AzureStore with values pre-populated from environment variables.</p> <p>Variables extracted from environment:</p> <ul> <li><code>AZURE_STORAGE_ACCOUNT_NAME</code>: storage account name</li> <li><code>AZURE_STORAGE_ACCOUNT_KEY</code>: storage account master key</li> <li><code>AZURE_STORAGE_ACCESS_KEY</code>: alias for <code>AZURE_STORAGE_ACCOUNT_KEY</code></li> <li><code>AZURE_STORAGE_CLIENT_ID</code> -&gt; client id for service principal authorization</li> <li><code>AZURE_STORAGE_CLIENT_SECRET</code> -&gt; client secret for service principal authorization</li> <li><code>AZURE_STORAGE_TENANT_ID</code> -&gt; tenant id used in oauth flows</li> </ul> <p>Parameters:</p> <ul> <li> <code>container</code>               (<code>str</code>)           \u2013            <p>description</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[AzureConfigKey, str] | None</code>)           \u2013            <p>Azure Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AzureStore</code>           \u2013            <p>AzureStore</p> </li> </ul>"},{"location":"api/store/azure/#obstore.store.AzureStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: Dict[AzureConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; AzureStore\n</code></pre> <p>Construct a new AzureStore with values populated from a well-known storage URL.</p> <p>The supported url schemes are:</p> <ul> <li><code>abfs[s]://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>abfs[s]://&lt;file_system&gt;@&lt;account_name&gt;.dfs.core.windows.net/&lt;path&gt;</code></li> <li><code>abfs[s]://&lt;file_system&gt;@&lt;account_name&gt;.dfs.fabric.microsoft.com/&lt;path&gt;</code></li> <li><code>az://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>adl://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>azure://&lt;container&gt;/&lt;path&gt;</code> (custom)</li> <li><code>https://&lt;account&gt;.dfs.core.windows.net</code></li> <li><code>https://&lt;account&gt;.blob.core.windows.net</code></li> <li><code>https://&lt;account&gt;.blob.core.windows.net/&lt;container&gt;</code></li> <li><code>https://&lt;account&gt;.dfs.fabric.microsoft.com</code></li> <li><code>https://&lt;account&gt;.dfs.fabric.microsoft.com/&lt;container&gt;</code></li> <li><code>https://&lt;account&gt;.blob.fabric.microsoft.com</code></li> <li><code>https://&lt;account&gt;.blob.fabric.microsoft.com/&lt;container&gt;</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[AzureConfigKey, str] | None</code>)           \u2013            <p>Azure Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AzureStore</code>           \u2013            <p>AzureStore</p> </li> </ul>"},{"location":"api/store/azure/#obstore.store.AzureConfigKey","title":"obstore.store.AzureConfigKey  <code>module-attribute</code>","text":"<pre><code>AzureConfigKey = Literal[\n    \"access_key\",\n    \"account_key\",\n    \"account_name\",\n    \"authority_id\",\n    \"azure_authority_id\",\n    \"azure_client_id\",\n    \"azure_client_secret\",\n    \"azure_container_name\",\n    \"azure_disable_tagging\",\n    \"azure_endpoint\",\n    \"azure_federated_token_file\",\n    \"azure_identity_endpoint\",\n    \"azure_msi_endpoint\",\n    \"azure_msi_resource_id\",\n    \"azure_object_id\",\n    \"azure_skip_signature\",\n    \"azure_storage_access_key\",\n    \"azure_storage_account_key\",\n    \"azure_storage_account_name\",\n    \"azure_storage_authority_id\",\n    \"azure_storage_client_id\",\n    \"azure_storage_client_secret\",\n    \"azure_storage_endpoint\",\n    \"azure_storage_master_key\",\n    \"azure_storage_sas_key\",\n    \"azure_storage_sas_token\",\n    \"azure_storage_tenant_id\",\n    \"azure_storage_token\",\n    \"azure_storage_use_emulator\",\n    \"azure_tenant_id\",\n    \"azure_use_azure_cli\",\n    \"azure_use_fabric_endpoint\",\n    \"bearer_token\",\n    \"client_id\",\n    \"client_secret\",\n    \"container_name\",\n    \"disable_tagging\",\n    \"endpoint\",\n    \"federated_token_file\",\n    \"identity_endpoint\",\n    \"master_key\",\n    \"msi_endpoint\",\n    \"msi_resource_id\",\n    \"object_id\",\n    \"sas_key\",\n    \"sas_token\",\n    \"skip_signature\",\n    \"tenant_id\",\n    \"token\",\n    \"use_azure_cli\",\n    \"use_emulator\",\n    \"use_fabric_endpoint\",\n    \"ACCESS_KEY\",\n    \"ACCOUNT_KEY\",\n    \"ACCOUNT_NAME\",\n    \"AUTHORITY_ID\",\n    \"AZURE_AUTHORITY_ID\",\n    \"AZURE_CLIENT_ID\",\n    \"AZURE_CLIENT_SECRET\",\n    \"AZURE_CONTAINER_NAME\",\n    \"AZURE_DISABLE_TAGGING\",\n    \"AZURE_ENDPOINT\",\n    \"AZURE_FEDERATED_TOKEN_FILE\",\n    \"AZURE_IDENTITY_ENDPOINT\",\n    \"AZURE_MSI_ENDPOINT\",\n    \"AZURE_MSI_RESOURCE_ID\",\n    \"AZURE_OBJECT_ID\",\n    \"AZURE_SKIP_SIGNATURE\",\n    \"AZURE_STORAGE_ACCESS_KEY\",\n    \"AZURE_STORAGE_ACCOUNT_KEY\",\n    \"AZURE_STORAGE_ACCOUNT_NAME\",\n    \"AZURE_STORAGE_AUTHORITY_ID\",\n    \"AZURE_STORAGE_CLIENT_ID\",\n    \"AZURE_STORAGE_CLIENT_SECRET\",\n    \"AZURE_STORAGE_ENDPOINT\",\n    \"AZURE_STORAGE_MASTER_KEY\",\n    \"AZURE_STORAGE_SAS_KEY\",\n    \"AZURE_STORAGE_SAS_TOKEN\",\n    \"AZURE_STORAGE_TENANT_ID\",\n    \"AZURE_STORAGE_TOKEN\",\n    \"AZURE_STORAGE_USE_EMULATOR\",\n    \"AZURE_TENANT_ID\",\n    \"AZURE_USE_AZURE_CLI\",\n    \"AZURE_USE_FABRIC_ENDPOINT\",\n    \"BEARER_TOKEN\",\n    \"CLIENT_ID\",\n    \"CLIENT_SECRET\",\n    \"CONTAINER_NAME\",\n    \"DISABLE_TAGGING\",\n    \"ENDPOINT\",\n    \"FEDERATED_TOKEN_FILE\",\n    \"IDENTITY_ENDPOINT\",\n    \"MASTER_KEY\",\n    \"MSI_ENDPOINT\",\n    \"MSI_RESOURCE_ID\",\n    \"OBJECT_ID\",\n    \"SAS_KEY\",\n    \"SAS_TOKEN\",\n    \"SKIP_SIGNATURE\",\n    \"TENANT_ID\",\n    \"TOKEN\",\n    \"USE_AZURE_CLI\",\n    \"USE_EMULATOR\",\n    \"USE_FABRIC_ENDPOINT\",\n]\n</code></pre> <p>Valid Azure storage configuration keys</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>\"azure_storage_account_key\"</code>, <code>\"azure_storage_access_key\"</code>, <code>\"azure_storage_master_key\"</code>, <code>\"master_key\"</code>, <code>\"account_key\"</code>, <code>\"access_key\"</code>: Master key for accessing storage account</li> <li><code>\"azure_storage_account_name\"</code>, <code>\"account_name\"</code>: The name of the azure storage account</li> <li><code>\"azure_storage_client_id\"</code>, <code>\"azure_client_id\"</code>, <code>\"client_id\"</code>: Service principal client id for authorizing requests</li> <li><code>\"azure_storage_client_secret\"</code>, <code>\"azure_client_secret\"</code>, <code>\"client_secret\"</code>: Service principal client secret for authorizing requests</li> <li><code>\"azure_storage_tenant_id\"</code>, <code>\"azure_storage_authority_id\"</code>, <code>\"azure_tenant_id\"</code>, <code>\"azure_authority_id\"</code>, <code>\"tenant_id\"</code>, <code>\"authority_id\"</code>: Tenant id used in oauth flows</li> <li> <p><code>\"azure_storage_sas_key\"</code>, <code>\"azure_storage_sas_token\"</code>, <code>\"sas_key\"</code>, <code>\"sas_token\"</code>: Shared access signature.</p> <p>The signature is expected to be percent-encoded, <code>much</code>like they are provided in the azure storage explorer or azure portal.</p> </li> <li> <p><code>\"azure_storage_token\"</code>, <code>\"bearer_token\"</code>, <code>\"token\"</code>: Bearer token</p> </li> <li><code>\"azure_storage_use_emulator\"</code>, <code>\"use_emulator\"</code>: Use object store with azurite storage emulator</li> <li><code>\"azure_storage_endpoint\"</code>, <code>\"azure_endpoint\"</code>, <code>\"endpoint\"</code>: Override the endpoint used to communicate with blob storage</li> <li><code>\"azure_msi_endpoint\"</code>, <code>\"azure_identity_endpoint\"</code>, <code>\"identity_endpoint\"</code>, <code>\"msi_endpoint\"</code>: Endpoint to request a imds managed identity token</li> <li><code>\"azure_object_id\"</code>, <code>\"object_id\"</code>: Object id for use with managed identity authentication</li> <li><code>\"azure_msi_resource_id\"</code>, <code>\"msi_resource_id\"</code>: Msi resource id for use with managed identity authentication</li> <li><code>\"azure_federated_token_file\"</code>, <code>\"federated_token_file\"</code>: File containing token for Azure AD workload identity federation</li> <li><code>\"azure_use_fabric_endpoint\"</code>, <code>\"use_fabric_endpoint\"</code>: Use object store with url scheme account.dfs.fabric.microsoft.com</li> <li><code>\"azure_use_azure_cli\"</code>, <code>\"use_azure_cli\"</code>: Use azure cli for acquiring access token</li> <li><code>\"azure_skip_signature\"</code>, <code>\"skip_signature\"</code>: Skip signing requests</li> <li><code>\"azure_container_name\"</code>, <code>\"container_name\"</code>: Container name</li> <li><code>\"azure_disable_tagging\"</code>, <code>\"disable_tagging\"</code>: Disables tagging objects</li> </ul>"},{"location":"api/store/config/","title":"Configuration","text":""},{"location":"api/store/config/#obstore.store.ClientConfigKey","title":"obstore.store.ClientConfigKey  <code>module-attribute</code>","text":"<pre><code>ClientConfigKey = Literal[\n    \"allow_http\",\n    \"allow_invalid_certificates\",\n    \"connect_timeout\",\n    \"default_content_type\",\n    \"http1_only\",\n    \"http2_keep_alive_interval\",\n    \"http2_keep_alive_timeout\",\n    \"http2_keep_alive_while_idle\",\n    \"http2_only\",\n    \"pool_idle_timeout\",\n    \"pool_max_idle_per_host\",\n    \"proxy_url\",\n    \"timeout\",\n    \"user_agent\",\n    \"ALLOW_HTTP\",\n    \"ALLOW_INVALID_CERTIFICATES\",\n    \"CONNECT_TIMEOUT\",\n    \"DEFAULT_CONTENT_TYPE\",\n    \"HTTP1_ONLY\",\n    \"HTTP2_KEEP_ALIVE_INTERVAL\",\n    \"HTTP2_KEEP_ALIVE_TIMEOUT\",\n    \"HTTP2_KEEP_ALIVE_WHILE_IDLE\",\n    \"HTTP2_ONLY\",\n    \"POOL_IDLE_TIMEOUT\",\n    \"POOL_MAX_IDLE_PER_HOST\",\n    \"PROXY_URL\",\n    \"TIMEOUT\",\n    \"USER_AGENT\",\n]\n</code></pre> <p>Allowed client configuration keys</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>\"allow_http\"</code>: Allow non-TLS, i.e. non-HTTPS connections.</li> <li> <p><code>\"allow_invalid_certificates\"</code>: Skip certificate validation on https connections.</p> <p>Warning</p> <p>You should think very carefully before using this method. If invalid certificates are trusted, any certificate for any site will be trusted for use. This includes expired certificates. This introduces significant vulnerabilities, and should only be used as a last resort or for testing</p> </li> <li> <p><code>\"connect_timeout\"</code>: Timeout for only the connect phase of a Client</p> </li> <li><code>\"default_content_type\"</code>: default <code>CONTENT_TYPE</code> for uploads</li> <li><code>\"http1_only\"</code>: Only use http1 connections.</li> <li><code>\"http2_keep_alive_interval\"</code>: Interval for HTTP2 Ping frames should be sent to keep a connection alive.</li> <li><code>\"http2_keep_alive_timeout\"</code>: Timeout for receiving an acknowledgement of the keep-alive ping.</li> <li><code>\"http2_keep_alive_while_idle\"</code>: Enable HTTP2 keep alive pings for idle connections</li> <li><code>\"http2_only\"</code>: Only use http2 connections</li> <li><code>\"pool_idle_timeout\"</code>: The pool max idle timeout.     This is the length of time an idle connection will be kept alive.</li> <li><code>\"pool_max_idle_per_host\"</code>: maximum number of idle connections per host.</li> <li><code>\"proxy_url\"</code>: HTTP proxy to use for requests.</li> <li><code>\"timeout\"</code>: Request timeout.     The timeout is applied from when the request starts connecting until the     response body has finished.</li> <li><code>\"user_agent\"</code>: User-Agent header to be used by this client.</li> </ul>"},{"location":"api/store/config/#obstore.store.BackoffConfig","title":"obstore.store.BackoffConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Exponential backoff with jitter</p> <p>See aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/</p>"},{"location":"api/store/config/#obstore.store.BackoffConfig.base","title":"base  <code>instance-attribute</code>","text":"<pre><code>base: int | float\n</code></pre> <p>The base of the exponential to use</p>"},{"location":"api/store/config/#obstore.store.BackoffConfig.init_backoff","title":"init_backoff  <code>instance-attribute</code>","text":"<pre><code>init_backoff: timedelta\n</code></pre> <p>The initial backoff duration</p>"},{"location":"api/store/config/#obstore.store.BackoffConfig.max_backoff","title":"max_backoff  <code>instance-attribute</code>","text":"<pre><code>max_backoff: timedelta\n</code></pre> <p>The maximum backoff duration</p>"},{"location":"api/store/config/#obstore.store.RetryConfig","title":"obstore.store.RetryConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>The configuration for how to respond to request errors</p> <p>The following categories of error will be retried:</p> <ul> <li>5xx server errors</li> <li>Connection errors</li> <li>Dropped connections</li> <li>Timeouts for safe / read-only requests</li> </ul> <p>Requests will be retried up to some limit, using exponential backoff with jitter. See <code>BackoffConfig</code> for more information</p>"},{"location":"api/store/config/#obstore.store.RetryConfig.backoff","title":"backoff  <code>instance-attribute</code>","text":"<pre><code>backoff: BackoffConfig\n</code></pre> <p>The backoff configuration</p>"},{"location":"api/store/config/#obstore.store.RetryConfig.max_retries","title":"max_retries  <code>instance-attribute</code>","text":"<pre><code>max_retries: int\n</code></pre> <p>The maximum number of times to retry a request</p> <p>Set to 0 to disable retries</p>"},{"location":"api/store/config/#obstore.store.RetryConfig.retry_timeout","title":"retry_timeout  <code>instance-attribute</code>","text":"<pre><code>retry_timeout: timedelta\n</code></pre> <p>The maximum length of time from the initial request after which no further retries will be attempted</p> <p>This not only bounds the length of time before a server error will be surfaced to the application, but also bounds the length of time a request's credentials must remain valid.</p> <p>As requests are retried without renewing credentials or regenerating request payloads, this number should be kept below 5 minutes to avoid errors due to expired credentials and/or request payloads</p>"},{"location":"api/store/gcs/","title":"Google Cloud Storage","text":""},{"location":"api/store/gcs/#obstore.store.GCSStore","title":"obstore.store.GCSStore","text":"<p>Configure a connection to Google Cloud Storage.</p> <p>If no credentials are explicitly provided, they will be sourced from the environment as documented here.</p>"},{"location":"api/store/gcs/#obstore.store.GCSStore.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(\n    bucket: str,\n    *,\n    config: Dict[GCSConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; GCSStore\n</code></pre> <p>Construct a new GCSStore with values pre-populated from environment variables.</p> <p>Variables extracted from environment:</p> <ul> <li><code>GOOGLE_SERVICE_ACCOUNT</code>: location of service account file</li> <li><code>GOOGLE_SERVICE_ACCOUNT_PATH</code>: (alias) location of service account file</li> <li><code>SERVICE_ACCOUNT</code>: (alias) location of service account file</li> <li><code>GOOGLE_SERVICE_ACCOUNT_KEY</code>: JSON serialized service account key</li> <li><code>GOOGLE_BUCKET</code>: bucket name</li> <li><code>GOOGLE_BUCKET_NAME</code>: (alias) bucket name</li> </ul> <p>Parameters:</p> <ul> <li> <code>bucket</code>               (<code>str</code>)           \u2013            <p>The GCS bucket to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[GCSConfigKey, str] | None</code>)           \u2013            <p>GCS Configuration. Values in this config will override values inferred from the environment. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GCSStore</code>           \u2013            <p>GCSStore</p> </li> </ul>"},{"location":"api/store/gcs/#obstore.store.GCSStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: Dict[GCSConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; GCSStore\n</code></pre> <p>Construct a new GCSStore with values populated from a well-known storage URL.</p> <p>The supported url schemes are:</p> <ul> <li><code>gs://&lt;bucket&gt;/&lt;path&gt;</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>Dict[GCSConfigKey, str] | None</code>)           \u2013            <p>GCS Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GCSStore</code>           \u2013            <p>GCSStore</p> </li> </ul>"},{"location":"api/store/gcs/#obstore.store.GCSConfigKey","title":"obstore.store.GCSConfigKey  <code>module-attribute</code>","text":"<pre><code>GCSConfigKey = Literal[\n    \"bucket_name\",\n    \"bucket\",\n    \"google_application_credentials\",\n    \"google_bucket_name\",\n    \"google_bucket\",\n    \"google_service_account_key\",\n    \"google_service_account_path\",\n    \"google_service_account\",\n    \"service_account_key\",\n    \"service_account_path\",\n    \"service_account\",\n    \"BUCKET_NAME\",\n    \"BUCKET\",\n    \"GOOGLE_APPLICATION_CREDENTIALS\",\n    \"GOOGLE_BUCKET_NAME\",\n    \"GOOGLE_BUCKET\",\n    \"GOOGLE_SERVICE_ACCOUNT_KEY\",\n    \"GOOGLE_SERVICE_ACCOUNT_PATH\",\n    \"GOOGLE_SERVICE_ACCOUNT\",\n    \"SERVICE_ACCOUNT_KEY\",\n    \"SERVICE_ACCOUNT_PATH\",\n    \"SERVICE_ACCOUNT\",\n]\n</code></pre> <p>Valid Google Cloud Storage configuration keys</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>\"google_service_account\"</code> or <code>\"service_account\"</code> or <code>\"google_service_account_path\"</code> or \"service_account_path\":  Path to the service account file.</li> <li><code>\"google_service_account_key\"</code> or <code>\"service_account_key\"</code>: The serialized service account key</li> <li><code>\"google_bucket\"</code> or <code>\"google_bucket_name\"</code> or <code>\"bucket\"</code> or <code>\"bucket_name\"</code>: Bucket name.</li> <li><code>\"google_application_credentials\"</code>: Application credentials path. See cloud.google.com/docs/authentication/provide-credentials-adc.</li> </ul>"},{"location":"api/store/http/","title":"HTTP","text":""},{"location":"api/store/http/#obstore.store.HTTPStore","title":"obstore.store.HTTPStore","text":"<p>Configure a connection to a generic HTTP server</p>"},{"location":"api/store/http/#obstore.store.HTTPStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; HTTPStore\n</code></pre> <p>Construct a new HTTPStore from a URL</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The base URL to use for the store.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HTTPStore</code>           \u2013            <p>HTTPStore</p> </li> </ul>"},{"location":"api/store/local/","title":"Local","text":""},{"location":"api/store/local/#obstore.store.LocalStore","title":"obstore.store.LocalStore","text":"<p>Local filesystem storage providing an ObjectStore interface to files on local disk. Can optionally be created with a directory prefix.</p> <pre><code>store = LocalStore()\nstore = LocalStore(prefix=\"/path/to/directory\")\n</code></pre>"},{"location":"api/store/memory/","title":"Memory","text":""},{"location":"api/store/memory/#obstore.store.MemoryStore","title":"obstore.store.MemoryStore","text":"<p>A fully in-memory implementation of ObjectStore.</p> <p>Create a new in-memory store: <pre><code>store = MemoryStore()\n</code></pre></p>"}]}